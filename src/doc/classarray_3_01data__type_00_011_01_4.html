<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Catalyst Lib: array&lt; data_type, 1 &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Catalyst Lib
   </div>
   <div id="projectbrief">Theoreticalchemistry/atomicandmolecularphysicscomputationproject.Justforfun.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classarray_3_01data__type_00_011_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">array&lt; data_type, 1 &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="array____rank__1_8hpp_source.html">array__rank_1.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa9fcb71e64978eaae814c3de31e86e8d"><td class="memItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#aa9fcb71e64978eaae814c3de31e86e8d">id</a> ()</td></tr>
<tr class="memdesc:aa9fcb71e64978eaae814c3de31e86e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new value in the given element position if the current object is an 1D, not deleted and not constant array. If <code>i</code> is out of range, nothing is done.  <a href="#aa9fcb71e64978eaae814c3de31e86e8d">More...</a><br/></td></tr>
<tr class="separator:aa9fcb71e64978eaae814c3de31e86e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4883bec40a9f33101e0c51eb4b2f8e6e"><td class="memItemLeft" align="right" valign="top">data_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a4883bec40a9f33101e0c51eb4b2f8e6e">min</a> () const </td></tr>
<tr class="memdesc:a4883bec40a9f33101e0c51eb4b2f8e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the current array was previously initialized, either by the constructor or the array::create() member function, array::min() returns the smaller element. Or returns zero, otherwise.  <a href="#a4883bec40a9f33101e0c51eb4b2f8e6e">More...</a><br/></td></tr>
<tr class="separator:a4883bec40a9f33101e0c51eb4b2f8e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a94a9325d120edff01c8f8c3c9d6b1"><td class="memItemLeft" align="right" valign="top">data_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#ab1a94a9325d120edff01c8f8c3c9d6b1">max</a> () const </td></tr>
<tr class="memdesc:ab1a94a9325d120edff01c8f8c3c9d6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the current array was previously initialized, either by the constructor or the array::create() member function, array::max() returns the higher element. Or returns zero, otherwise.  <a href="#ab1a94a9325d120edff01c8f8c3c9d6b1">More...</a><br/></td></tr>
<tr class="separator:ab1a94a9325d120edff01c8f8c3c9d6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfa82dde609c6d4000a6a3ae28c5d34"><td class="memItemLeft" align="right" valign="top">data_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#adbfa82dde609c6d4000a6a3ae28c5d34">sum</a> ()</td></tr>
<tr class="memdesc:adbfa82dde609c6d4000a6a3ae28c5d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the current array was previously initialized, either by the constructor or the array::create() member function, array::sum() returns the summation of all the elements. Or returns zero, otherwise.  <a href="#adbfa82dde609c6d4000a6a3ae28c5d34">More...</a><br/></td></tr>
<tr class="separator:adbfa82dde609c6d4000a6a3ae28c5d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ebcd776b5012f8141718b1d5b98fc0d"><td class="memItemLeft" align="right" valign="top">constexpr short unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a9ebcd776b5012f8141718b1d5b98fc0d">rank</a> () const </td></tr>
<tr class="memdesc:a9ebcd776b5012f8141718b1d5b98fc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current dimensionality.  <a href="#a9ebcd776b5012f8141718b1d5b98fc0d">More...</a><br/></td></tr>
<tr class="separator:a9ebcd776b5012f8141718b1d5b98fc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45aaef8224faa39efbb2efdc8efe5e1c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a45aaef8224faa39efbb2efdc8efe5e1c">norm</a> ()</td></tr>
<tr class="memdesc:a45aaef8224faa39efbb2efdc8efe5e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the CBLAS library to calculate the euclidean norm of the array. Valid for rank one arrays only.  <a href="#a45aaef8224faa39efbb2efdc8efe5e1c">More...</a><br/></td></tr>
<tr class="separator:a45aaef8224faa39efbb2efdc8efe5e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed24f309732f0408f17cc954831133b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#aed24f309732f0408f17cc954831133b0">sort</a> ()</td></tr>
<tr class="memdesc:aed24f309732f0408f17cc954831133b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the current array was previously initialized, either by the constructor or the array::create() member function, array::sort() sorts the current values in some order.  <a href="#aed24f309732f0408f17cc954831133b0">More...</a><br/></td></tr>
<tr class="separator:aed24f309732f0408f17cc954831133b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae131ff86bcd3b6e67527a1afab064a9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#ae131ff86bcd3b6e67527a1afab064a9c">clear</a> ()</td></tr>
<tr class="memdesc:ae131ff86bcd3b6e67527a1afab064a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the current array was previously initialized, either by the constructor or the array::create() member function, array::clear() will delete the current data, deallocating the memory used. After this, to use the object again, array::create() should be invoked first, to reallocate the memory.  <a href="#ae131ff86bcd3b6e67527a1afab064a9c">More...</a><br/></td></tr>
<tr class="separator:ae131ff86bcd3b6e67527a1afab064a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08e557c7bbd07c47c6f404e52a7cd20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#ae08e557c7bbd07c47c6f404e52a7cd20">has_nan</a> () const </td></tr>
<tr class="memdesc:ae08e557c7bbd07c47c6f404e52a7cd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if at least one element of the current array is a <code>nan</code>, i.e. not-a-number, such as <code>'0/0'</code> or <code>'std::sqrt</code>(-1)'.  <a href="#ae08e557c7bbd07c47c6f404e52a7cd20">More...</a><br/></td></tr>
<tr class="separator:ae08e557c7bbd07c47c6f404e52a7cd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1358244eb780c2afdceac1e2f76efa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a7b1358244eb780c2afdceac1e2f76efa">is_null</a> () const </td></tr>
<tr class="memdesc:a7b1358244eb780c2afdceac1e2f76efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all the elements of the current array are zero.  <a href="#a7b1358244eb780c2afdceac1e2f76efa">More...</a><br/></td></tr>
<tr class="separator:a7b1358244eb780c2afdceac1e2f76efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa083802119d026529bf440ba6ee37748"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#aa083802119d026529bf440ba6ee37748">set_all</a> (data_type input)</td></tr>
<tr class="memdesc:aa083802119d026529bf440ba6ee37748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given <code>input</code> in all the elements, if the array was previously initialized either by the constructor or the array::create() member function. Otherwise nothing is really done.  <a href="#aa083802119d026529bf440ba6ee37748">More...</a><br/></td></tr>
<tr class="separator:aa083802119d026529bf440ba6ee37748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57668e580961e811d414e0f9fc3c9b9d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a57668e580961e811d414e0f9fc3c9b9d">set_zero</a> ()</td></tr>
<tr class="memdesc:a57668e580961e811d414e0f9fc3c9b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operator <code>+</code> applied between two rank one arrays, add up each element and returns the resulting array by the move assignment or the move constructor. Only if both arrays were previously initialized either by the constructor or the array::create() member function, and their size are the same. Otherwise nothing is done.  <a href="#a57668e580961e811d414e0f9fc3c9b9d">More...</a><br/></td></tr>
<tr class="separator:a57668e580961e811d414e0f9fc3c9b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9342e506139f1f711e32d2a29bebc23"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#ab9342e506139f1f711e32d2a29bebc23">is_ready</a> () const </td></tr>
<tr class="memdesc:ab9342e506139f1f711e32d2a29bebc23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the current array was previously initialized either by the constructor or by the array::create() member function. Case not, there is no memory allocated and the array must be initialized first.  <a href="#ab9342e506139f1f711e32d2a29bebc23">More...</a><br/></td></tr>
<tr class="separator:ab9342e506139f1f711e32d2a29bebc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77143f9ec70a1c69659a8ccaaa8091f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#ae77143f9ec70a1c69659a8ccaaa8091f">operator=</a> (data_type input)</td></tr>
<tr class="memdesc:ae77143f9ec70a1c69659a8ccaaa8091f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operator <code>=</code> is used to copy the elements from the given <code>input</code> array to the current one. If the current size is not either equal or grater than the <code>input</code> one, the object is going to be resized on-the-fly. Thus, for performance reasons, is always recommended to use an operator between objects of the same size. If any of the arrays are not previously initialized by the constructor or the array::create() member function, nothing is done.  <a href="#ae77143f9ec70a1c69659a8ccaaa8091f">More...</a><br/></td></tr>
<tr class="separator:ae77143f9ec70a1c69659a8ccaaa8091f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a15d30119d32248386b5fc15f42b205"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a6a15d30119d32248386b5fc15f42b205">~array</a> ()</td></tr>
<tr class="separator:a6a15d30119d32248386b5fc15f42b205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9458dbd5f58fbfc5a06f0d6cc4c09b48"><td class="memItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a9458dbd5f58fbfc5a06f0d6cc4c09b48">first_rank</a> () const </td></tr>
<tr class="memdesc:a9458dbd5f58fbfc5a06f0d6cc4c09b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the first rank.  <a href="#a9458dbd5f58fbfc5a06f0d6cc4c09b48">More...</a><br/></td></tr>
<tr class="separator:a9458dbd5f58fbfc5a06f0d6cc4c09b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a24597864de633bc296eec0e704ddbf"><td class="memItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a8a24597864de633bc296eec0e704ddbf">third_rank</a> () const </td></tr>
<tr class="memdesc:a8a24597864de633bc296eec0e704ddbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the third rank.  <a href="#a8a24597864de633bc296eec0e704ddbf">More...</a><br/></td></tr>
<tr class="separator:a8a24597864de633bc296eec0e704ddbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da5a9603ae460534dc5e11d7dba0176"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a2da5a9603ae460534dc5e11d7dba0176">is_positive</a> () const </td></tr>
<tr class="memdesc:a2da5a9603ae460534dc5e11d7dba0176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all the elements of the current array are positive, including zero as an unsigned number, i.e. nonegative.  <a href="#a2da5a9603ae460534dc5e11d7dba0176">More...</a><br/></td></tr>
<tr class="separator:a2da5a9603ae460534dc5e11d7dba0176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc814d1188d76baed693f7ddaf1d8295"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#adc814d1188d76baed693f7ddaf1d8295">is_negative</a> () const </td></tr>
<tr class="memdesc:adc814d1188d76baed693f7ddaf1d8295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all the elements of the current array are negative.  <a href="#adc814d1188d76baed693f7ddaf1d8295">More...</a><br/></td></tr>
<tr class="separator:adc814d1188d76baed693f7ddaf1d8295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0aea0cec5287c39f0735b9cdb5623a"><td class="memItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a8c0aea0cec5287c39f0735b9cdb5623a">fourth_rank</a> () const </td></tr>
<tr class="memdesc:a8c0aea0cec5287c39f0735b9cdb5623a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operator <code>+</code> applied between an 1D array object (at left) and a number of the same data type (at right), adds the given number to all the elements of the array. Such operation takes place only if the current array was previously initialized either by the constructor or the array::create() member function.  <a href="#a8c0aea0cec5287c39f0735b9cdb5623a">More...</a><br/></td></tr>
<tr class="separator:a8c0aea0cec5287c39f0735b9cdb5623a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c109fff2335f2686e18286d09231a9"><td class="memItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#ae0c109fff2335f2686e18286d09231a9">second_rank</a> () const </td></tr>
<tr class="memdesc:ae0c109fff2335f2686e18286d09231a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the second rank.  <a href="#ae0c109fff2335f2686e18286d09231a9">More...</a><br/></td></tr>
<tr class="separator:ae0c109fff2335f2686e18286d09231a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76a930681db6dd3ec3ffe1e0ec63677"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#ae76a930681db6dd3ec3ffe1e0ec63677">build_randomly</a> ()</td></tr>
<tr class="memdesc:ae76a930681db6dd3ec3ffe1e0ec63677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value in the <img class="formulaInl" alt="$ A_{i} $" src="form_9.png"/> element. This function does not checks the array bounds. If the given element is out of range, it throws the standard C/C++ out of range error (and/or segmentation fault).  <a href="#ae76a930681db6dd3ec3ffe1e0ec63677">More...</a><br/></td></tr>
<tr class="separator:ae76a930681db6dd3ec3ffe1e0ec63677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b8300e914cb12a3e02d732256339e1"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#ac5b8300e914cb12a3e02d732256339e1">array</a> ()</td></tr>
<tr class="memdesc:ac5b8300e914cb12a3e02d732256339e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor used to declare 1D arrays objects with no defined shape and no allocated memory. Before use any object constructed in such way, i.e. not previously initialized, the <code>array::create()</code> member function should be invoked first to allocate memory and define the array shape.  <a href="#ac5b8300e914cb12a3e02d732256339e1">More...</a><br/></td></tr>
<tr class="separator:ac5b8300e914cb12a3e02d732256339e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f1123cbc4cbf7abb85477f5d992dbe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#ab9f1123cbc4cbf7abb85477f5d992dbe">array</a> (const unsigned int &amp;<a class="el" href="file__system____size_8cpp.html#aa5700d96289cb02d565f63c1f9348b74">size</a>)</td></tr>
<tr class="memdesc:ab9f1123cbc4cbf7abb85477f5d992dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The constructor used to declare 1D arrays objects with <code>size</code> length. The memory is allocated by default and the elements are initialized to zero. To check if the current array was well constructed, the <code>array::is_ready()</code> member function can be used. To free the used memory, the array::reset() member should be invoked and the result is an array object as constructed by the default constructor. Any attempt to reuse it will need to reallocate the memory first by means of the array::create() function.  <a href="#ab9f1123cbc4cbf7abb85477f5d992dbe">More...</a><br/></td></tr>
<tr class="separator:ab9f1123cbc4cbf7abb85477f5d992dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23220bab39236725f0850c1d748268b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a23220bab39236725f0850c1d748268b2">array</a> (const <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt; &amp;input)</td></tr>
<tr class="memdesc:a23220bab39236725f0850c1d748268b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The copy constructor...  <a href="#a23220bab39236725f0850c1d748268b2">More...</a><br/></td></tr>
<tr class="separator:a23220bab39236725f0850c1d748268b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a15d30119d32248386b5fc15f42b205"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a6a15d30119d32248386b5fc15f42b205">~array</a> ()</td></tr>
<tr class="separator:a6a15d30119d32248386b5fc15f42b205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1278ca73460f49c17ded0dc013882a0c"><td class="memItemLeft" align="right" valign="top">data_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a1278ca73460f49c17ded0dc013882a0c">operator()</a> (const unsigned int &amp;i) const </td></tr>
<tr class="memdesc:a1278ca73460f49c17ded0dc013882a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value in the <img class="formulaInl" alt="$ A_{i} $" src="form_9.png"/> element. This function does not checks the array bounds. If the given element is out of range, it throws the standard C/C++ out of range error (and/or segmentation fault).  <a href="#a1278ca73460f49c17ded0dc013882a0c">More...</a><br/></td></tr>
<tr class="separator:a1278ca73460f49c17ded0dc013882a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5b5bba7dfd9e7539fac624027f7b8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a8a5b5bba7dfd9e7539fac624027f7b8f">operator()</a> (const unsigned int &amp;i, const data_type &amp;input)</td></tr>
<tr class="memdesc:a8a5b5bba7dfd9e7539fac624027f7b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given <code>input</code> in the <img class="formulaInl" alt="$ A_{i} $" src="form_9.png"/> element. This function does not checks the array bounds. If the given element is out of range, it throws the standard C/C++ out of range error (and/or segmentation fault).  <a href="#a8a5b5bba7dfd9e7539fac624027f7b8f">More...</a><br/></td></tr>
<tr class="separator:a8a5b5bba7dfd9e7539fac624027f7b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b3a053410f2243b844817615064e75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#af4b3a053410f2243b844817615064e75">operator=</a> (const <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt; &amp;input)</td></tr>
<tr class="memdesc:af4b3a053410f2243b844817615064e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operator <code>=</code> is used to copy the elements from the given <code>input</code> array to the current one. If the current size is not either equal or grater than the <code>input</code> one, the object is going to be resized on-the-fly. Thus, for performance reasons, is always recommended to use an operator between objects of the same size. If any of the arrays are not previously initialized by the constructor or the array::create() member function, nothing is done.  <a href="#af4b3a053410f2243b844817615064e75">More...</a><br/></td></tr>
<tr class="separator:af4b3a053410f2243b844817615064e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb994bcb1a7741a5088a8576d9f1fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarray.html">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#acdb994bcb1a7741a5088a8576d9f1fbf">operator+</a> (const data_type &amp;input)</td></tr>
<tr class="memdesc:acdb994bcb1a7741a5088a8576d9f1fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operator <code>+</code> applied between an 1D array object (at left) and a number of the same data type (at right), adds the given number to all the elements of the array. Such operation takes place only if the current array was previously initialized either by the constructor or the array::create() member function.  <a href="#acdb994bcb1a7741a5088a8576d9f1fbf">More...</a><br/></td></tr>
<tr class="separator:acdb994bcb1a7741a5088a8576d9f1fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c559f11071a7d0bd4671383f13629f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarray.html">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a41c559f11071a7d0bd4671383f13629f">operator-</a> (const data_type &amp;input)</td></tr>
<tr class="memdesc:a41c559f11071a7d0bd4671383f13629f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operator <code>-</code> applied between an 1D array object (at left) and a number of the same data type (at right), subs the given number to all the elements of the array. Such operation takes place only if the current array was previously initialized either by the constructor or the array::create() member function.  <a href="#a41c559f11071a7d0bd4671383f13629f">More...</a><br/></td></tr>
<tr class="separator:a41c559f11071a7d0bd4671383f13629f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75820c37bb82ccbb1347c529d627eb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarray.html">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#aa75820c37bb82ccbb1347c529d627eb6">operator*</a> (const data_type &amp;input)</td></tr>
<tr class="memdesc:aa75820c37bb82ccbb1347c529d627eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operator <code>*</code> applied between an 1D array object (at left) and a number of the same data type (at right), scales the current array by the given factor. Such operation takes place only if the current array was previously initialized either by the constructor or the array::create() member function.  <a href="#aa75820c37bb82ccbb1347c529d627eb6">More...</a><br/></td></tr>
<tr class="separator:aa75820c37bb82ccbb1347c529d627eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6382add52bc828c06a61206e4c818a7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarray.html">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a6382add52bc828c06a61206e4c818a7b">operator/</a> (const data_type &amp;input)</td></tr>
<tr class="memdesc:a6382add52bc828c06a61206e4c818a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operator <code>/</code> applied between an 1D array object (at left) and a number of the same data type (at right), divides the current array by the given factor. Such operation takes place only if the current array was previously initialized either by the constructor or the array::create() member function.  <a href="#a6382add52bc828c06a61206e4c818a7b">More...</a><br/></td></tr>
<tr class="separator:a6382add52bc828c06a61206e4c818a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d2ca76980ade923fb8d2152d74e79c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarray.html">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a23d2ca76980ade923fb8d2152d74e79c">operator+</a> (const <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt; &amp;input)</td></tr>
<tr class="memdesc:a23d2ca76980ade923fb8d2152d74e79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operator <code>+</code> applied between two 1D array objects adds them in a new 1D array. Such operation takes place only if both objects were previously initialized either by the constructor or the array::create() member function. In the cases that the first ranks length doesn't fits each other, nothing is done.  <a href="#a23d2ca76980ade923fb8d2152d74e79c">More...</a><br/></td></tr>
<tr class="separator:a23d2ca76980ade923fb8d2152d74e79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad511fdcfe8e552c1c3008ce988af2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classarray.html">array</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a2ad511fdcfe8e552c1c3008ce988af2a">operator-</a> (const <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt; &amp;input)</td></tr>
<tr class="memdesc:a2ad511fdcfe8e552c1c3008ce988af2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operator <code>-</code> applied between two 1D array objects subs them in a new 1D array. Such operation takes place only if both objects were previously initialized either by the constructor or the array::create() member function. In the cases that the first ranks length doesn't fits each other, nothing is done.  <a href="#a2ad511fdcfe8e552c1c3008ce988af2a">More...</a><br/></td></tr>
<tr class="separator:a2ad511fdcfe8e552c1c3008ce988af2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf64daa001e6a8de447de3eec7073296"><td class="memItemLeft" align="right" valign="top">data_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#abf64daa001e6a8de447de3eec7073296">operator*</a> (const <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt; &amp;input)</td></tr>
<tr class="memdesc:abf64daa001e6a8de447de3eec7073296"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operator <code>*</code> applied between two 1D array objects returns the scalar product between them. Such operation takes place only if both objects were previously initialized either by the constructor or the array::create() member function. In the cases that the first ranks length doesn't fits each other, it returns zero.  <a href="#abf64daa001e6a8de447de3eec7073296">More...</a><br/></td></tr>
<tr class="separator:abf64daa001e6a8de447de3eec7073296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8682b3e13e914034d9ef7a5a114cd2a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a8682b3e13e914034d9ef7a5a114cd2a6">create</a> (unsigned int &amp;<a class="el" href="file__system____size_8cpp.html#aa5700d96289cb02d565f63c1f9348b74">size</a>)</td></tr>
<tr class="memdesc:a8682b3e13e914034d9ef7a5a114cd2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function is designed to those cases when the array object was declared without the bounds and do not have any memory allocated. Thus, before to be used, array::create() will allocate memory and setup all the elements to zero. In the cases of an already allocated array object, any attempt to resize it should be done through the array::resize() instead.  <a href="#a8682b3e13e914034d9ef7a5a114cd2a6">More...</a><br/></td></tr>
<tr class="separator:a8682b3e13e914034d9ef7a5a114cd2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297477b9cea702e2af36af42671f51f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a297477b9cea702e2af36af42671f51f7">resize</a> (const unsigned int &amp;new_size)</td></tr>
<tr class="memdesc:a297477b9cea702e2af36af42671f51f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This member function will resize the current object if it was previously properly initialized either by the constructor or by the array::create() member function.  <a href="#a297477b9cea702e2af36af42671f51f7">More...</a><br/></td></tr>
<tr class="separator:a297477b9cea702e2af36af42671f51f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f59daec0a2e2c338343e0a8a746e66"><td class="memItemLeft" align="right" valign="top">short unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a95f59daec0a2e2c338343e0a8a746e66">rank</a> () const </td></tr>
<tr class="memdesc:a95f59daec0a2e2c338343e0a8a746e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current dimensionality.  <a href="#a95f59daec0a2e2c338343e0a8a746e66">More...</a><br/></td></tr>
<tr class="separator:a95f59daec0a2e2c338343e0a8a746e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d05836d5d93c2eb3748c5c601d16be3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a1d05836d5d93c2eb3748c5c601d16be3">first_rank</a> () const </td></tr>
<tr class="memdesc:a1d05836d5d93c2eb3748c5c601d16be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the first rank.  <a href="#a1d05836d5d93c2eb3748c5c601d16be3">More...</a><br/></td></tr>
<tr class="separator:a1d05836d5d93c2eb3748c5c601d16be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b27bc7e66655abfc9be406c6a2cbbc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a40b27bc7e66655abfc9be406c6a2cbbc">second_rank</a> () const </td></tr>
<tr class="memdesc:a40b27bc7e66655abfc9be406c6a2cbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the second rank.  <a href="#a40b27bc7e66655abfc9be406c6a2cbbc">More...</a><br/></td></tr>
<tr class="separator:a40b27bc7e66655abfc9be406c6a2cbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556dd58a171635adda79c9a738f99c4f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a556dd58a171635adda79c9a738f99c4f">third_rank</a> () const </td></tr>
<tr class="memdesc:a556dd58a171635adda79c9a738f99c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the third rank.  <a href="#a556dd58a171635adda79c9a738f99c4f">More...</a><br/></td></tr>
<tr class="separator:a556dd58a171635adda79c9a738f99c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdc77635c46773e6fad12aaeb6407e0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a6cdc77635c46773e6fad12aaeb6407e0">fourth_rank</a> () const </td></tr>
<tr class="memdesc:a6cdc77635c46773e6fad12aaeb6407e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the fourth rank.  <a href="#a6cdc77635c46773e6fad12aaeb6407e0">More...</a><br/></td></tr>
<tr class="separator:a6cdc77635c46773e6fad12aaeb6407e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637b3a52e29550be9022d1b5d646ea1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a637b3a52e29550be9022d1b5d646ea1c">is_ready</a> () const </td></tr>
<tr class="memdesc:a637b3a52e29550be9022d1b5d646ea1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the fourth rank.  <a href="#a637b3a52e29550be9022d1b5d646ea1c">More...</a><br/></td></tr>
<tr class="separator:a637b3a52e29550be9022d1b5d646ea1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7540532beb25f06d662bf332d89bd3b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a7540532beb25f06d662bf332d89bd3b4">set</a> (const unsigned int &amp;i, const data_type &amp;input)</td></tr>
<tr class="memdesc:a7540532beb25f06d662bf332d89bd3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given <code>input</code> in the <img class="formulaInl" alt="$ A_{i} $" src="form_9.png"/> element, checking if it is inside the array length. To avoid the bounds check-in, the operator <code></code>() can be uesd instead.  <a href="#a7540532beb25f06d662bf332d89bd3b4">More...</a><br/></td></tr>
<tr class="separator:a7540532beb25f06d662bf332d89bd3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0aa35f2412b9585ddb607e0e1af4a80"><td class="memItemLeft" align="right" valign="top">data_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#ae0aa35f2412b9585ddb607e0e1af4a80">get</a> (const unsigned int &amp;i)</td></tr>
<tr class="memdesc:ae0aa35f2412b9585ddb607e0e1af4a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <img class="formulaInl" alt="$ A_{i} $" src="form_9.png"/> element, checking if it is inside the array length. To avoid the bounds check-in, the operator <code></code>() can be uesd instead.  <a href="#ae0aa35f2412b9585ddb607e0e1af4a80">More...</a><br/></td></tr>
<tr class="separator:ae0aa35f2412b9585ddb607e0e1af4a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6d42c0e1712f2916ba03eaab87fd32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a2c6d42c0e1712f2916ba03eaab87fd32">set_all</a> (const data_type &amp;input)</td></tr>
<tr class="memdesc:a2c6d42c0e1712f2916ba03eaab87fd32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the given <code>input</code> in all the elements, if the array was previously initialized either by the constructor or the array::create() member function. Otherwise nothing is done.  <a href="#a2c6d42c0e1712f2916ba03eaab87fd32">More...</a><br/></td></tr>
<tr class="separator:a2c6d42c0e1712f2916ba03eaab87fd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fbaaf1cfe830bd200fb16c5e068445"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a34fbaaf1cfe830bd200fb16c5e068445">reset</a> ()</td></tr>
<tr class="memdesc:a34fbaaf1cfe830bd200fb16c5e068445"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the current array was previously initialized, either by the constructor or the array::create() member function, this one is going to delete the current data, deallocating the memory used. After this, to use the object again, array::create() should be invoked first, to reallocate the memory.  <a href="#a34fbaaf1cfe830bd200fb16c5e068445">More...</a><br/></td></tr>
<tr class="separator:a34fbaaf1cfe830bd200fb16c5e068445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0473c116ee608c175c0fd62047badb98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a0473c116ee608c175c0fd62047badb98">move_to</a> (<a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt; &amp;output)</td></tr>
<tr class="separator:a0473c116ee608c175c0fd62047badb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76a930681db6dd3ec3ffe1e0ec63677"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#ae76a930681db6dd3ec3ffe1e0ec63677">build_randomly</a> ()</td></tr>
<tr class="separator:ae76a930681db6dd3ec3ffe1e0ec63677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4883bec40a9f33101e0c51eb4b2f8e6e"><td class="memItemLeft" align="right" valign="top">data_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a4883bec40a9f33101e0c51eb4b2f8e6e">min</a> () const </td></tr>
<tr class="separator:a4883bec40a9f33101e0c51eb4b2f8e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a94a9325d120edff01c8f8c3c9d6b1"><td class="memItemLeft" align="right" valign="top">data_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#ab1a94a9325d120edff01c8f8c3c9d6b1">max</a> () const </td></tr>
<tr class="separator:ab1a94a9325d120edff01c8f8c3c9d6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed24f309732f0408f17cc954831133b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#aed24f309732f0408f17cc954831133b0">sort</a> ()</td></tr>
<tr class="separator:aed24f309732f0408f17cc954831133b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfa82dde609c6d4000a6a3ae28c5d34"><td class="memItemLeft" align="right" valign="top">data_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#adbfa82dde609c6d4000a6a3ae28c5d34">sum</a> ()</td></tr>
<tr class="separator:adbfa82dde609c6d4000a6a3ae28c5d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba99a7258e77767175202c6a429aba7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#afba99a7258e77767175202c6a429aba7">write</a> ()</td></tr>
<tr class="separator:afba99a7258e77767175202c6a429aba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a1e359861b651f222a969a72209bff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a93a1e359861b651f222a969a72209bff">save</a> ()</td></tr>
<tr class="separator:a93a1e359861b651f222a969a72209bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308e93ecc1f79942dc24433ce84d792f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a308e93ecc1f79942dc24433ce84d792f">load</a> ()</td></tr>
<tr class="separator:a308e93ecc1f79942dc24433ce84d792f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1358244eb780c2afdceac1e2f76efa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a7b1358244eb780c2afdceac1e2f76efa">is_null</a> () const </td></tr>
<tr class="memdesc:a7b1358244eb780c2afdceac1e2f76efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all the elements of the current array are zero.  <a href="#a7b1358244eb780c2afdceac1e2f76efa">More...</a><br/></td></tr>
<tr class="separator:a7b1358244eb780c2afdceac1e2f76efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da5a9603ae460534dc5e11d7dba0176"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a2da5a9603ae460534dc5e11d7dba0176">is_positive</a> () const </td></tr>
<tr class="memdesc:a2da5a9603ae460534dc5e11d7dba0176"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all the elements of the current array are positive, including zero as an unsigned number, i.e. nonegative.  <a href="#a2da5a9603ae460534dc5e11d7dba0176">More...</a><br/></td></tr>
<tr class="separator:a2da5a9603ae460534dc5e11d7dba0176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc814d1188d76baed693f7ddaf1d8295"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#adc814d1188d76baed693f7ddaf1d8295">is_negative</a> () const </td></tr>
<tr class="memdesc:adc814d1188d76baed693f7ddaf1d8295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all the elements of the current array are negative.  <a href="#adc814d1188d76baed693f7ddaf1d8295">More...</a><br/></td></tr>
<tr class="separator:adc814d1188d76baed693f7ddaf1d8295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08e557c7bbd07c47c6f404e52a7cd20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#ae08e557c7bbd07c47c6f404e52a7cd20">has_nan</a> () const </td></tr>
<tr class="memdesc:ae08e557c7bbd07c47c6f404e52a7cd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if at least one element of the current array is a 'nan', i.e. not-a-number, like <code>0/0</code> or <code>sqrt</code>(-1).  <a href="#ae08e557c7bbd07c47c6f404e52a7cd20">More...</a><br/></td></tr>
<tr class="separator:ae08e557c7bbd07c47c6f404e52a7cd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aac2ec46ad0a22f4597ce6d3b5f46cd4b"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#aac2ec46ad0a22f4597ce6d3b5f46cd4b">id</a> = 2431</td></tr>
<tr class="separator:aac2ec46ad0a22f4597ce6d3b5f46cd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa7c58e42f1793c4153540fc0632b3a36"><td class="memItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#aa7c58e42f1793c4153540fc0632b3a36">offset</a> (unsigned int i) const </td></tr>
<tr class="memdesc:aa7c58e42f1793c4153540fc0632b3a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">A help function used to calculate the real position, i.e. the offset, of a given element in a rank 1 array in the <code>data</code> member.  <a href="#aa7c58e42f1793c4153540fc0632b3a36">More...</a><br/></td></tr>
<tr class="separator:aa7c58e42f1793c4153540fc0632b3a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3fca73645b6145052b38d8f25c9217"><td class="memItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a3a3fca73645b6145052b38d8f25c9217">offset</a> (unsigned int i, unsigned int j) const </td></tr>
<tr class="memdesc:a3a3fca73645b6145052b38d8f25c9217"><td class="mdescLeft">&#160;</td><td class="mdescRight">A help function used to calculate the real position, i.e. the offset, of a given element in a rank 2 array in the <code>data</code> member.  <a href="#a3a3fca73645b6145052b38d8f25c9217">More...</a><br/></td></tr>
<tr class="separator:a3a3fca73645b6145052b38d8f25c9217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92618b14f64af1481678047464a1203e"><td class="memItemLeft" align="right" valign="top">constexpr data_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a92618b14f64af1481678047464a1203e">data_end</a> () const </td></tr>
<tr class="memdesc:a92618b14f64af1481678047464a1203e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A help function used to check the pointer pointing the.  <a href="#a92618b14f64af1481678047464a1203e">More...</a><br/></td></tr>
<tr class="separator:a92618b14f64af1481678047464a1203e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff2d7bde34c7ff032b6be7a9b3b5c41"><td class="memItemLeft" align="right" valign="top">constexpr unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#adff2d7bde34c7ff032b6be7a9b3b5c41">data_length</a> () const </td></tr>
<tr class="memdesc:adff2d7bde34c7ff032b6be7a9b3b5c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">A help function to allocate memory for a rank one array.  <a href="#adff2d7bde34c7ff032b6be7a9b3b5c41">More...</a><br/></td></tr>
<tr class="separator:adff2d7bde34c7ff032b6be7a9b3b5c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640c212aa688d26d8f5c75cf6bcc7325"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a640c212aa688d26d8f5c75cf6bcc7325">delete_data</a> ()</td></tr>
<tr class="memdesc:a640c212aa688d26d8f5c75cf6bcc7325"><td class="mdescLeft">&#160;</td><td class="mdescRight">A help function to deallocate the current memory and to set zero the rank's lengths.  <a href="#a640c212aa688d26d8f5c75cf6bcc7325">More...</a><br/></td></tr>
<tr class="separator:a640c212aa688d26d8f5c75cf6bcc7325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c27ad3d65219df464a79f58e9353f24"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a4c27ad3d65219df464a79f58e9353f24">offset</a> (unsigned int i) const </td></tr>
<tr class="separator:a4c27ad3d65219df464a79f58e9353f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5f40124567f7bc911b9687e15119557a"><td class="memItemLeft" align="right" valign="top">data_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a5f40124567f7bc911b9687e15119557a">data</a></td></tr>
<tr class="memdesc:a5f40124567f7bc911b9687e15119557a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operator <code>+</code> applied between an 1D array object (at left) and a number of the same data type (at right), adds the given number to all the elements of the array. Such operation takes place only if the current array was previously initialized either by the constructor or the array::create() member function.  <a href="#a5f40124567f7bc911b9687e15119557a">More...</a><br/></td></tr>
<tr class="separator:a5f40124567f7bc911b9687e15119557a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49501f0efdffbc4c1db27d509797212c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classarray_3_01data__type_00_011_01_4.html#a49501f0efdffbc4c1db27d509797212c">rank1</a></td></tr>
<tr class="separator:a49501f0efdffbc4c1db27d509797212c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6a15d30119d32248386b5fc15f42b205"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::~<a class="el" href="classarray.html">array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac5b8300e914cb12a3e02d732256339e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::<a class="el" href="classarray.html">array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The default constructor used to declare 1D arrays objects with no defined shape and no allocated memory. Before use any object constructed in such way, i.e. not previously initialized, the <code>array::create()</code> member function should be invoked first to allocate memory and define the array shape. </p>

</div>
</div>
<a class="anchor" id="ab9f1123cbc4cbf7abb85477f5d992dbe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::<a class="el" href="classarray.html">array</a> </td>
          <td>(</td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The constructor used to declare 1D arrays objects with <code>size</code> length. The memory is allocated by default and the elements are initialized to zero. To check if the current array was well constructed, the <code>array::is_ready()</code> member function can be used. To free the used memory, the array::reset() member should be invoked and the result is an array object as constructed by the default constructor. Any attempt to reuse it will need to reallocate the memory first by means of the array::create() function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">The</td><td>first rank length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23220bab39236725f0850c1d748268b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::<a class="el" href="classarray.html">array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The copy constructor... </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>previously declared 1D array object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a15d30119d32248386b5fc15f42b205"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::~<a class="el" href="classarray.html">array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae76a930681db6dd3ec3ffe1e0ec63677"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::build_randomly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current value in the <img class="formulaInl" alt="$ A_{i} $" src="form_9.png"/> element. This function does not checks the array bounds. If the given element is out of range, it throws the standard C/C++ out of range error (and/or segmentation fault). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The i array element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A numerical data of the same type of the current array. If the current array was previously initialized, either by the constructor or the array::create() member function, array::build_randomly() replaces the data by random numbers generated in the range between zero and five times the rank size. </dd>
<dd>
<code>EXIT_SUCCESS</code> or <code>EXIT_FAILURE</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae76a930681db6dd3ec3ffe1e0ec63677"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::build_randomly </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae131ff86bcd3b6e67527a1afab064a9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the current array was previously initialized, either by the constructor or the array::create() member function, array::clear() will delete the current data, deallocating the memory used. After this, to use the object again, array::create() should be invoked first, to reallocate the memory. </p>
<dl class="section return"><dt>Returns</dt><dd><code>EXIT_SUCCESS</code> or <code>EXIT_FAILURE</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Please notice, this member function does not replace the class destructor that is going to be called by default in the right moment. The main usage of this function is to free memory when desired. </dd></dl>

</div>
</div>
<a class="anchor" id="a8682b3e13e914034d9ef7a5a114cd2a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::create </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function is designed to those cases when the array object was declared without the bounds and do not have any memory allocated. Thus, before to be used, array::create() will allocate memory and setup all the elements to zero. In the cases of an already allocated array object, any attempt to resize it should be done through the array::resize() instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The first rank length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>EXIT_SUCCESS</code> or <code>EXIT_FAILURE</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a92618b14f64af1481678047464a1203e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr data_type* <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::data_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A help function used to check the pointer pointing the. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer of the same type of the current array. </dd></dl>

</div>
</div>
<a class="anchor" id="adff2d7bde34c7ff032b6be7a9b3b5c41"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::data_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A help function to allocate memory for a rank one array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The first rank length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>EXIT_SUCCESS</code> if the allocation was successful, and <code>EXIT_FAILURE</code> otherwise. A help function used to check the internal real length of the current array. </dd>
<dd>
A nonnegative integer. </dd></dl>

</div>
</div>
<a class="anchor" id="a640c212aa688d26d8f5c75cf6bcc7325"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::delete_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A help function to deallocate the current memory and to set zero the rank's lengths. </p>
<dl class="section return"><dt>Returns</dt><dd><code>EXIT_SUCCESS</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9458dbd5f58fbfc5a06f0d6cc4c09b48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::first_rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the first rank. </p>
<dl class="section return"><dt>Returns</dt><dd>A nonnegative integer number. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d05836d5d93c2eb3748c5c601d16be3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::first_rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the first rank. </p>
<dl class="section return"><dt>Returns</dt><dd>A nonnegative integer number. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c0aea0cec5287c39f0735b9cdb5623a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::fourth_rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The operator <code>+</code> applied between an 1D array object (at left) and a number of the same data type (at right), adds the given number to all the elements of the array. Such operation takes place only if the current array was previously initialized either by the constructor or the array::create() member function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A real number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An 1D array object (by value). Returns the length of the fourth rank. </dd>
<dd>
A nonnegative integer number. </dd></dl>

</div>
</div>
<a class="anchor" id="a6cdc77635c46773e6fad12aaeb6407e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::fourth_rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the fourth rank. </p>
<dl class="section return"><dt>Returns</dt><dd>A nonnegative integer number. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0aa35f2412b9585ddb607e0e1af4a80"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">data_type <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <img class="formulaInl" alt="$ A_{i} $" src="form_9.png"/> element, checking if it is inside the array length. To avoid the bounds check-in, the operator <code></code>() can be uesd instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The array element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A numerical data of the same type of the current array. </dd></dl>

</div>
</div>
<a class="anchor" id="ae08e557c7bbd07c47c6f404e52a7cd20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::has_nan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if at least one element of the current array is a <code>nan</code>, i.e. not-a-number, such as <code>'0/0'</code> or <code>'std::sqrt</code>(-1)'. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if it has one or more <code>nan</code>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae08e557c7bbd07c47c6f404e52a7cd20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::has_nan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if at least one element of the current array is a 'nan', i.e. not-a-number, like <code>0/0</code> or <code>sqrt</code>(-1). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if it has one or more 'nan', <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9fcb71e64978eaae814c3de31e86e8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a new value in the given element position if the current object is an 1D, not deleted and not constant array. If <code>i</code> is out of range, nothing is done. </p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="adc814d1188d76baed693f7ddaf1d8295"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::is_negative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if all the elements of the current array are negative. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all the elements are negative, <code>false</code> otherwise, or if the current array was not previously initialized by the constructor or the array::create() member funtion. </dd></dl>

</div>
</div>
<a class="anchor" id="adc814d1188d76baed693f7ddaf1d8295"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::is_negative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if all the elements of the current array are negative. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all the elements are negative, <code>false</code> otherwise, or if the current array was not previously initialized by the constructor or the array::create() member funtion. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b1358244eb780c2afdceac1e2f76efa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::is_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if all the elements of the current array are zero. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all the elements are zero or if the current array was not previously initialized by the constructor or the array::create() member funtion. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b1358244eb780c2afdceac1e2f76efa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::is_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if all the elements of the current array are zero. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all the elements are zero or if the current array was not previously initialized by the constructor or the array::create() member funtion. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2da5a9603ae460534dc5e11d7dba0176"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::is_positive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if all the elements of the current array are positive, including zero as an unsigned number, i.e. nonegative. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all the elements are positive, <code>false</code> otherwise, or if the current array was not previously initialized by the constructor or the array::create() member funtion. </dd></dl>

</div>
</div>
<a class="anchor" id="a2da5a9603ae460534dc5e11d7dba0176"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::is_positive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if all the elements of the current array are positive, including zero as an unsigned number, i.e. nonegative. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all the elements are positive, <code>false</code> otherwise, or if the current array was not previously initialized by the constructor or the array::create() member funtion. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9342e506139f1f711e32d2a29bebc23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::is_ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the current array was previously initialized either by the constructor or by the array::create() member function. Case not, there is no memory allocated and the array must be initialized first. </p>
<dl class="section return"><dt>Returns</dt><dd>if ready or , otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a637b3a52e29550be9022d1b5d646ea1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::is_ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the fourth rank. </p>
<dl class="section return"><dt>Returns</dt><dd>A nonnegative integer number. </dd></dl>

</div>
</div>
<a class="anchor" id="a308e93ecc1f79942dc24433ce84d792f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::load </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab1a94a9325d120edff01c8f8c3c9d6b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">data_type <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the current array was previously initialized, either by the constructor or the array::create() member function, array::max() returns the higher element. Or returns zero, otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>A numerical data of the same type of the current array. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1a94a9325d120edff01c8f8c3c9d6b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">data_type <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4883bec40a9f33101e0c51eb4b2f8e6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">data_type <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the current array was previously initialized, either by the constructor or the array::create() member function, array::min() returns the smaller element. Or returns zero, otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>A numerical data of the same type of the current array. </dd></dl>

</div>
</div>
<a class="anchor" id="a4883bec40a9f33101e0c51eb4b2f8e6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">data_type <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0473c116ee608c175c0fd62047badb98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::move_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a45aaef8224faa39efbb2efdc8efe5e1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the CBLAS library to calculate the euclidean norm of the array. Valid for rank one arrays only. </p>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$ \sqrt{A^{2}_{1} + \ldots + A^{2}_{n}} $" src="form_16.png"/>, where <img class="formulaInl" alt="$ n = $" src="form_17.png"/> <code>array::first_rank()</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7c58e42f1793c4153540fc0632b3a36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::offset </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A help function used to calculate the real position, i.e. the offset, of a given element in a rank 1 array in the <code>data</code> member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The i-th element of the first rank.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$ := i - 1 $" src="form_18.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="a3a3fca73645b6145052b38d8f25c9217"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::offset </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A help function used to calculate the real position, i.e. the offset, of a given element in a rank 2 array in the <code>data</code> member. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The i-th element of the first rank.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>The j-th element of the second rank.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$ := i - 1 $" src="form_18.png"/> </dd></dl>

</div>
</div>
<a class="anchor" id="a4c27ad3d65219df464a79f58e9353f24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::offset </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1278ca73460f49c17ded0dc013882a0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">data_type&amp; <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current value in the <img class="formulaInl" alt="$ A_{i} $" src="form_9.png"/> element. This function does not checks the array bounds. If the given element is out of range, it throws the standard C/C++ out of range error (and/or segmentation fault). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The array element.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A numerical data of the same type of the current array. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a5b5bba7dfd9e7539fac624027f7b8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const data_type &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given <code>input</code> in the <img class="formulaInl" alt="$ A_{i} $" src="form_9.png"/> element. This function does not checks the array bounds. If the given element is out of range, it throws the standard C/C++ out of range error (and/or segmentation fault). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The array element.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The element new value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa75820c37bb82ccbb1347c529d627eb6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray.html">array</a> <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const data_type &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The operator <code>*</code> applied between an 1D array object (at left) and a number of the same data type (at right), scales the current array by the given factor. Such operation takes place only if the current array was previously initialized either by the constructor or the array::create() member function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A real number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An 1D array object (by value). </dd></dl>

</div>
</div>
<a class="anchor" id="abf64daa001e6a8de447de3eec7073296"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">data_type <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The operator <code>*</code> applied between two 1D array objects returns the scalar product between them. Such operation takes place only if both objects were previously initialized either by the constructor or the array::create() member function. In the cases that the first ranks length doesn't fits each other, it returns zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A real number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$ (A_{1} \cdot B_{1}) + (A_{2} \cdot B_{2}) + \ldots + (A_{n} \cdot B_{n}) $" src="form_13.png"/>, where <img class="formulaInl" alt="$ n := $" src="form_14.png"/> <code>array::first_rank()</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="acdb994bcb1a7741a5088a8576d9f1fbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray.html">array</a> <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const data_type &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The operator <code>+</code> applied between an 1D array object (at left) and a number of the same data type (at right), adds the given number to all the elements of the array. Such operation takes place only if the current array was previously initialized either by the constructor or the array::create() member function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A real number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An 1D array object (by value). </dd></dl>

</div>
</div>
<a class="anchor" id="a23d2ca76980ade923fb8d2152d74e79c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray.html">array</a> <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The operator <code>+</code> applied between two 1D array objects adds them in a new 1D array. Such operation takes place only if both objects were previously initialized either by the constructor or the array::create() member function. In the cases that the first ranks length doesn't fits each other, nothing is done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A previously declared 1D array object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An 1D array object (by value). </dd></dl>

</div>
</div>
<a class="anchor" id="a41c559f11071a7d0bd4671383f13629f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray.html">array</a> <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const data_type &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The operator <code>-</code> applied between an 1D array object (at left) and a number of the same data type (at right), subs the given number to all the elements of the array. Such operation takes place only if the current array was previously initialized either by the constructor or the array::create() member function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A real number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An 1D array object (by value). </dd></dl>

</div>
</div>
<a class="anchor" id="a2ad511fdcfe8e552c1c3008ce988af2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray.html">array</a> <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The operator <code>-</code> applied between two 1D array objects subs them in a new 1D array. Such operation takes place only if both objects were previously initialized either by the constructor or the array::create() member function. In the cases that the first ranks length doesn't fits each other, nothing is done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A real number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An 1D array object (by value). </dd></dl>

</div>
</div>
<a class="anchor" id="a6382add52bc828c06a61206e4c818a7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classarray.html">array</a> <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::operator/ </td>
          <td>(</td>
          <td class="paramtype">const data_type &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The operator <code>/</code> applied between an 1D array object (at left) and a number of the same data type (at right), divides the current array by the given factor. Such operation takes place only if the current array was previously initialized either by the constructor or the array::create() member function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A real number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An 1D array object (by value). </dd></dl>

</div>
</div>
<a class="anchor" id="ae77143f9ec70a1c69659a8ccaaa8091f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">data_type&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The operator <code>=</code> is used to copy the elements from the given <code>input</code> array to the current one. If the current size is not either equal or grater than the <code>input</code> one, the object is going to be resized on-the-fly. Thus, for performance reasons, is always recommended to use an operator between objects of the same size. If any of the arrays are not previously initialized by the constructor or the array::create() member function, nothing is done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A previously declared 1D array object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af4b3a053410f2243b844817615064e75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The operator <code>=</code> is used to copy the elements from the given <code>input</code> array to the current one. If the current size is not either equal or grater than the <code>input</code> one, the object is going to be resized on-the-fly. Thus, for performance reasons, is always recommended to use an operator between objects of the same size. If any of the arrays are not previously initialized by the constructor or the array::create() member function, nothing is done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A previously declared 1D array object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ebcd776b5012f8141718b1d5b98fc0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr short unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current dimensionality. </p>
<dl class="section return"><dt>Returns</dt><dd>A nonnegative integer number. </dd></dl>

</div>
</div>
<a class="anchor" id="a95f59daec0a2e2c338343e0a8a746e66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">short unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current dimensionality. </p>
<dl class="section return"><dt>Returns</dt><dd>A nonnegative integer number. </dd></dl>

</div>
</div>
<a class="anchor" id="a34fbaaf1cfe830bd200fb16c5e068445"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the current array was previously initialized, either by the constructor or the array::create() member function, this one is going to delete the current data, deallocating the memory used. After this, to use the object again, array::create() should be invoked first, to reallocate the memory. </p>
<dl class="section return"><dt>Returns</dt><dd><code>EXIT_SUCCESS</code> or <code>EXIT_FAILURE</code>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Please notice, this member function does not replace the class destructor that is going to be called by default in the right moment. The main usage of this function is to free memory when desired. </dd></dl>

</div>
</div>
<a class="anchor" id="a297477b9cea702e2af36af42671f51f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This member function will resize the current object if it was previously properly initialized either by the constructor or by the array::create() member function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The first rank length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>EXIT_SUCCESS</code> or <code>EXIT_FAILURE</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a93a1e359861b651f222a969a72209bff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::save </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae0c109fff2335f2686e18286d09231a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::second_rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the second rank. </p>
<dl class="section return"><dt>Returns</dt><dd>A nonnegative integer number. </dd></dl>

</div>
</div>
<a class="anchor" id="a40b27bc7e66655abfc9be406c6a2cbbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::second_rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the second rank. </p>
<dl class="section return"><dt>Returns</dt><dd>A nonnegative integer number. </dd></dl>

</div>
</div>
<a class="anchor" id="a7540532beb25f06d662bf332d89bd3b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const data_type &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given <code>input</code> in the <img class="formulaInl" alt="$ A_{i} $" src="form_9.png"/> element, checking if it is inside the array length. To avoid the bounds check-in, the operator <code></code>() can be uesd instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>The array element.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The element new value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa083802119d026529bf440ba6ee37748"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::set_all </td>
          <td>(</td>
          <td class="paramtype">data_type&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given <code>input</code> in all the elements, if the array was previously initialized either by the constructor or the array::create() member function. Otherwise nothing is really done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A new value for all the elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>EXIT_SUCCESS</code> or <code>EXIT_FAILURE</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c6d42c0e1712f2916ba03eaab87fd32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::set_all </td>
          <td>(</td>
          <td class="paramtype">const data_type &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the given <code>input</code> in all the elements, if the array was previously initialized either by the constructor or the array::create() member function. Otherwise nothing is done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>The new value for all the elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>EXIT_SUCCESS</code> or <code>EXIT_FAILURE</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a57668e580961e811d414e0f9fc3c9b9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::set_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The operator <code>+</code> applied between two rank one arrays, add up each element and returns the resulting array by the move assignment or the move constructor. Only if both arrays were previously initialized either by the constructor or the array::create() member function, and their size are the same. Otherwise nothing is done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A previously declared rank one array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A rank one array. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Notice that if the macro <code>'NO_RANGE_CHECK'</code> was previously defined, the operator do not check either the initialization or the sizes. The caller should ensure the conditions to work properly. Otherwise segmentation fault or any out of range standard C++ error will abort the runtime. Sets zero in all the elements, if the array was previously initialized either by the constructor or the array::create() member function. Otherwise nothing is really done. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>EXIT_SUCCESS</code> or <code>EXIT_FAILURE</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aed24f309732f0408f17cc954831133b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the current array was previously initialized, either by the constructor or the array::create() member function, array::sort() sorts the current values in some order. </p>
<dl class="section return"><dt>Returns</dt><dd><code>EXIT_SUCCESS</code> or <code>EXIT_FAILURE</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aed24f309732f0408f17cc954831133b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adbfa82dde609c6d4000a6a3ae28c5d34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">data_type <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the current array was previously initialized, either by the constructor or the array::create() member function, array::sum() returns the summation of all the elements. Or returns zero, otherwise. </p>
<dl class="section return"><dt>Returns</dt><dd>A numerical data of the same type of the current array. </dd></dl>

</div>
</div>
<a class="anchor" id="adbfa82dde609c6d4000a6a3ae28c5d34"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">data_type <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8a24597864de633bc296eec0e704ddbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::third_rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the third rank. </p>
<dl class="section return"><dt>Returns</dt><dd>A nonnegative integer number. </dd></dl>

</div>
</div>
<a class="anchor" id="a556dd58a171635adda79c9a738f99c4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::third_rank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the third rank. </p>
<dl class="section return"><dt>Returns</dt><dd>A nonnegative integer number. </dd></dl>

</div>
</div>
<a class="anchor" id="afba99a7258e77767175202c6a429aba7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a5f40124567f7bc911b9687e15119557a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">data_type * <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The operator <code>+</code> applied between an 1D array object (at left) and a number of the same data type (at right), adds the given number to all the elements of the array. Such operation takes place only if the current array was previously initialized either by the constructor or the array::create() member function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>A real number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An 1D array object (by value). </dd></dl>

</div>
</div>
<a class="anchor" id="aac2ec46ad0a22f4597ce6d3b5f46cd4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::id = 2431</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a49501f0efdffbc4c1db27d509797212c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename data_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classarray.html">array</a>&lt; data_type, 1 &gt;::rank1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Nov 8 2014 19:45:54 for Catalyst Lib by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
